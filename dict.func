;;  ██████╗██████╗ ███████╗ █████╗ ████████╗██╗ ██████╗ ███╗   ██╗
;; ██╔════╝██╔══██╗██╔════╝██╔══██╗╚══██╔══╝██║██╔═══██╗████╗  ██║
;; ██║     ██████╔╝█████╗  ███████║   ██║   ██║██║   ██║██╔██╗ ██║
;; ██║     ██╔══██╗██╔══╝  ██╔══██║   ██║   ██║██║   ██║██║╚██╗██║
;; ╚██████╗██║  ██║███████╗██║  ██║   ██║   ██║╚██████╔╝██║ ╚████║
;;  ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝


;;; Creates a new empty dictionary represented by a maybe Cell.
;;;
;;; Args:
;;;   None
;;;
;;; Returns:
;;;   cell: A Null value representing the empty dictionary.
cell new_dict() asm "NEWDICT";

;;; Checks if a dictionary (maybe Cell) is empty.
;;;
;;; Args:
;;;   c (cell): Dictionary (maybe Cell) to check.
;;;
;;; Returns:
;;;   int: -1 if the dictionary is Null (empty), 0 otherwise.
int dict_empty?(cell c) asm "DICTEMPTY";


;;  ██╗██████╗ ███████╗██╗ ███████╗███████╗██████╗ ██╗ █████╗ ██╗     ██╗███████╗ █████╗ ████████╗██╗ ██████╗ ███╗   ██╗
;; ██╔╝██╔══██╗██╔════╝╚██╗██╔════╝██╔════╝██╔══██╗██║██╔══██╗██║     ██║╚══███╔╝██╔══██╗╚══██╔══╝██║██╔═══██╗████╗  ██║
;; ██║ ██║  ██║█████╗   ██║███████╗█████╗  ██████╔╝██║███████║██║     ██║  ███╔╝ ███████║   ██║   ██║██║   ██║██╔██╗ ██║
;; ██║ ██║  ██║██╔══╝   ██║╚════██║██╔══╝  ██╔══██╗██║██╔══██║██║     ██║ ███╔╝  ██╔══██║   ██║   ██║██║   ██║██║╚██╗██║
;; ╚██╗██████╔╝███████╗██╔╝███████║███████╗██║  ██║██║██║  ██║███████╗██║███████╗██║  ██║   ██║   ██║╚██████╔╝██║ ╚████║
;;  ╚═╝╚═════╝ ╚══════╝╚═╝ ╚══════╝╚══════╝╚═╝  ╚═╝╚═╝╚═╝  ╚═╝╚══════╝╚═╝╚══════╝╚═╝  ╚═╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝


;;; Stores a dictionary (maybe Cell representation) into a builder.
;;;
;;; Args:
;;;   b (builder): Builder to store the dictionary into.
;;;   c (cell): Dictionary (maybe Cell) to store.
;;;
;;; Returns:
;;;   builder: Resulting builder with the dictionary stored.
builder store_dict(builder b, cell c) asm(c b) "STDICT";
(builder, ()) ~store_dict(builder b, cell c) asm(c b) "STDICT";

;;; Loads (parses) a dictionary (maybe Cell) from a slice.
;;;
;;; Args:
;;;   s (slice): Slice containing the serialized dictionary.
;;;
;;; Returns:
;;;   slice: Remainder of the slice after loading.
;;;   cell: The loaded dictionary (maybe Cell).
(slice, cell) load_dict(slice s) asm( -> 1 0) "LDDICT";

;;; Loads (parses) a dictionary (maybe Cell) from a slice, returning a success flag.
;;;
;;; Args:
;;;   s (slice): Slice containing the serialized dictionary.
;;;
;;; Returns:
;;;   slice: Remainder of the slice if successful, original slice otherwise.
;;;   cell: The loaded dictionary (maybe Cell, null if unsuccessful).
;;;   int: Success flag: -1 if successful, 0 otherwise.
(slice, cell, int) load_dict?(slice s) asm(-> 1 0 2) "LDDICTQ" "NULLROTRIFNOT";
(slice, (cell, int)) ~load_dict?(slice s) asm(-> 1 0 2) "LDDICTQ" "NULLROTRIFNOT";

;;; Preloads a dictionary (maybe Cell) from a slice.
;;;
;;; Args:
;;;   s (slice): Slice containing the serialized dictionary.
;;;
;;; Returns:
;;;   cell: The preloaded dictionary (maybe Cell).
cell preload_dict(slice s) asm "PLDDICT";


;;; Preloads a dictionary (maybe Cell) from a slice, returning a success flag.
;;;
;;; Args:
;;;   s (slice): Slice containing the serialized dictionary.
;;;
;;; Returns:
;;;   cell: The preloaded dictionary (maybe Cell, null if unsuccessful).
;;;   int: Success flag: -1 if successful, 0 otherwise.
(cell, int) preload_dict?(slice s) asm "PLDDICTQ" "NULLSWAPIFNOT";


;;; Skips a dictionary (maybe Cell) in a slice.
;;;
;;; Args:
;;;   s (slice): Slice containing the serialized dictionary.
;;;
;;; Returns:
;;;   slice: Remainder of the slice after skipping the dictionary.
slice skip_dict(slice s) asm "SKIPDICT";
(slice, ()) ~skip_dict(slice s) asm "SKIPDICT";


;;  ██████╗ ███████╗████████╗     ██████╗ ██████╗ ███████╗
;; ██╔════╝ ██╔════╝╚══██╔══╝    ██╔═══██╗██╔══██╗██╔════╝
;; ██║  ███╗█████╗     ██║       ██║   ██║██████╔╝███████╗
;; ██║   ██║██╔══╝     ██║       ██║   ██║██╔═══╝ ╚════██║
;; ╚██████╔╝███████╗   ██║       ╚██████╔╝██║     ███████║
;;  ╚═════╝ ╚══════╝   ╚═╝        ╚═════╝ ╚═╝     ╚══════╝


;;; Looks up a key in a dictionary and returns the corresponding value slice.
;;;
;;; Args:
;;;   dict (cell): Dictionary to search in.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to look up (slice, signed int, or unsigned int).
;;;
;;; Returns:
;;;   slice: Value associated with the key (null if key not found).
;;;   int: Success flag: -1 if key was found, 0 if not found.
(slice, int) dict_get?(cell dict, int key_len, slice index) asm(index dict key_len) "DICTGET" "NULLSWAPIFNOT";
(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGET" "NULLSWAPIFNOT";
(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGET" "NULLSWAPIFNOT";

;;; Looks up a key in a dictionary and returns the corresponding value cell.
;;;
;;; Args:
;;;   dict (cell): Dictionary to search in.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to look up (slice, signed int, or unsigned int).
;;;
;;; Returns:
;;;   cell: Cell associated with the key (null if key not found).
;;;   int: Success flag: -1 if key was found, 0 if not found.
(cell, int) dict_get_ref?(cell dict, int key_len, slice index) asm(index dict key_len) "DICTGETREF" "NULLSWAPIFNOT";
(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGETREF" "NULLSWAPIFNOT";
(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGETREF" "NULLSWAPIFNOT";


;; ███████╗███████╗████████╗     ██████╗ ██████╗ ███████╗
;; ██╔════╝██╔════╝╚══██╔══╝    ██╔═══██╗██╔══██╗██╔════╝
;; ███████╗█████╗     ██║       ██║   ██║██████╔╝███████╗
;; ╚════██║██╔══╝     ██║       ██║   ██║██╔═══╝ ╚════██║
;; ███████║███████╗   ██║       ╚██████╔╝██║     ███████║
;; ╚══════╝╚══════╝   ╚═╝        ╚═════╝ ╚═╝     ╚══════╝


;;; Sets or replaces a slice value for a key in a dictionary.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to set (slice, signed int, or unsigned int).
;;;   value (slice): Value to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary.
cell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTSET";
(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTSET";
cell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTISET";
(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTISET";
cell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";
(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";

;;; Sets or replaces a cell value for a key in a dictionary.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to set (slice, signed int, or unsigned int).
;;;   value (cell): Cell to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary.
cell dict_set_ref(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) "DICTSETREF";
(cell, ()) ~dict_set_ref(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) "DICTSETREF";
cell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";
(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";
cell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETREF";
(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETREF";

;;; Sets a new value for a key and returns the old value if the key existed.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to set (slice, signed int, or unsigned int).
;;;   value (slice): Value to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary.
;;;   slice: The old value if the key existed, or null if the key was new.
;;;   int: Success flag: -1 if key existed, 0 if key was new.
(cell, slice, int) dict_set_get?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTSETGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~dict_set_get?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTSETGET" "NULLSWAPIFNOT";
(cell, slice, int) idict_set_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTISETGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~idict_set_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTISETGET" "NULLSWAPIFNOT";
(cell, slice, int) udict_set_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSETGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~udict_set_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSETGET" "NULLSWAPIFNOT";

;;; Sets a new cell value for a key and returns the old cell if the key existed.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to set (slice, signed int, or unsigned int).
;;;   value (cell): Cell to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary.
;;;   cell: The old cell if the key existed, or null if the key was new.
;;;   int: Success flag: -1 if key existed, 0 if key was new.
(cell, cell, int) dict_set_get_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) "DICTSETGETREF" "NULLSWAPIFNOT";
(cell, (cell, int)) ~dict_set_get_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) "DICTSETGETREF" "NULLSWAPIFNOT";
(cell, cell, int) idict_set_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETGETREF" "NULLSWAPIFNOT";
(cell, (cell, int)) ~idict_set_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETGETREF" "NULLSWAPIFNOT";
(cell, cell, int) udict_set_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETGETREF" "NULLSWAPIFNOT";
(cell, (cell, int)) ~udict_set_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETGETREF" "NULLSWAPIFNOT";

;;; Sets a value for a key in a dictionary, with the value provided as a builder.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to set (slice, signed int, or unsigned int).
;;;   value (builder): Builder containing the value to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary.
cell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTSETB";
(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTSETB";
cell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTISETB";
(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTISETB";
cell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETB";
(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETB";

;;; Sets a new builder value for a key and returns the old value if the key existed.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to set (slice, signed int, or unsigned int).
;;;   value (builder): Builder containing the value to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary.
;;;   slice: The old value if the key existed, or null if the key was new.
;;;   int: Success flag: -1 if key existed, 0 if key was new.
(cell, slice, int) dict_set_get_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTSETGETB" "NULLSWAPIFNOT";
(cell, (slice, int)) ~dict_set_get_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTSETGETB" "NULLSWAPIFNOT";
(cell, slice, int) idict_set_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTISETGETB" "NULLSWAPIFNOT";
(cell, (slice, int)) ~idict_set_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTISETGETB" "NULLSWAPIFNOT";
(cell, slice, int) udict_set_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETGETB" "NULLSWAPIFNOT";
(cell, (slice, int)) ~udict_set_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETGETB" "NULLSWAPIFNOT";


;; ██████╗ ███████╗██████╗ ██╗      █████╗  ██████╗███████╗     ██████╗ ██████╗ ███████╗
;; ██╔══██╗██╔════╝██╔══██╗██║     ██╔══██╗██╔════╝██╔════╝    ██╔═══██╗██╔══██╗██╔════╝
;; ██████╔╝█████╗  ██████╔╝██║     ███████║██║     █████╗      ██║   ██║██████╔╝███████╗
;; ██╔══██╗██╔══╝  ██╔═══╝ ██║     ██╔══██║██║     ██╔══╝      ██║   ██║██╔═══╝ ╚════██║
;; ██║  ██║███████╗██║     ███████╗██║  ██║╚██████╗███████╗    ╚██████╔╝██║     ███████║
;; ╚═╝  ╚═╝╚══════╝╚═╝     ╚══════╝╚═╝  ╚═╝ ╚═════╝╚══════╝     ╚═════╝ ╚═╝     ╚══════╝


;;; Replaces a value for a key in the dictionary, only if the key already exists.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to update (slice, signed int, or unsigned int).
;;;   value (slice): New value to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary if key found, original dictionary otherwise.
;;;   int: Success flag: -1 if key was found and replaced, 0 otherwise.
(cell, int) dict_replace?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTREPLACE";
(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIREPLACE";
(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUREPLACE";

;;; Replaces a cell value for a key in the dictionary, only if the key already exists.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to update (slice, signed int, or unsigned int).
;;;   value (cell): New cell to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary if key found, original dictionary otherwise.
;;;   int: Success flag: -1 if key was found and replaced, 0 otherwise.
(cell, int) dict_replace_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) "DICTREPLACEREF";
(cell, int) idict_replace_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTIREPLACEREF";
(cell, int) udict_replace_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUREPLACEREF";

;;; Replaces a value for a key if it exists, and returns the old value.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to update (slice, signed int, or unsigned int).
;;;   value (slice): New value to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary if key existed, original dictionary otherwise.
;;;   slice: The old value if the key existed (when flag is -1), or null otherwise (when flag is 0).
;;;   int: Success flag: -1 if key was found and replaced, 0 otherwise.
(cell, slice, int) dict_replace_get?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTREPLACEGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~dict_replace_get?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTREPLACEGET" "NULLSWAPIFNOT";
(cell, slice, int) udict_replace_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUREPLACEGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~udict_replace_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUREPLACEGET" "NULLSWAPIFNOT";
(cell, slice, int) idict_replace_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIREPLACEGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~idict_replace_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIREPLACEGET" "NULLSWAPIFNOT";

;;; Replaces a cell value for a key if it exists, and returns the old cell.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to update (slice, signed int, or unsigned int).
;;;   value (cell): New cell to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary if key existed, original dictionary otherwise.
;;;   cell: The old cell if the key existed (when flag is -1), or null otherwise (when flag is 0).
;;;   int: Success flag: -1 if key was found and replaced, 0 otherwise.
(cell, cell, int) dict_replace_get_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) "DICTREPLACEGETREF" "NULLSWAPIFNOT";
(cell, (cell, int)) ~dict_replace_get_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) "DICTREPLACEGETREF" "NULLSWAPIFNOT";
(cell, cell, int) idict_replace_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTIREPLACEGETREF" "NULLSWAPIFNOT";
(cell, (cell, int)) ~idict_replace_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTIREPLACEGETREF" "NULLSWAPIFNOT";
(cell, cell, int) udict_replace_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUREPLACEGETREF" "NULLSWAPIFNOT";
(cell, (cell, int)) ~udict_replace_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUREPLACEGETREF" "NULLSWAPIFNOT";

;;; Replaces a value for a key using a builder, only if the key already exists.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to update (slice, signed int, or unsigned int).
;;;   value (builder): Builder containing the new value to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary if key found, original dictionary otherwise.
;;;   int: Success flag: -1 if key was found and replaced, 0 otherwise.
(cell, int) dict_replace_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTREPLACEB";
(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIREPLACEB";
(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUREPLACEB";

;;; Replaces a value using a builder if the key exists, and returns the old value.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to update (slice, signed int, or unsigned int).
;;;   value (builder): Builder containing the new value to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary if key existed, original dictionary otherwise.
;;;   slice: The old value if the key existed (when flag is -1), or null otherwise (when flag is 0).
;;;   int: Success flag: -1 if key was found and replaced, 0 otherwise.
(cell, slice, int) dict_replace_get_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTREPLACEGETB" "NULLSWAPIFNOT";
(cell, (slice, int)) ~dict_replace_get_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTREPLACEGETB" "NULLSWAPIFNOT";
(cell, slice, int) idict_replace_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIREPLACEGETB" "NULLSWAPIFNOT";
(cell, (slice, int)) ~idict_replace_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIREPLACEGETB" "NULLSWAPIFNOT";
(cell, slice, int) udict_replace_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUREPLACEGETB" "NULLSWAPIFNOT";
(cell, (slice, int)) ~udict_replace_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUREPLACEGETB" "NULLSWAPIFNOT";


;;  █████╗ ██████╗ ██████╗      ██████╗ ██████╗ ███████╗
;; ██╔══██╗██╔══██╗██╔══██╗    ██╔═══██╗██╔══██╗██╔════╝
;; ███████║██║  ██║██║  ██║    ██║   ██║██████╔╝███████╗
;; ██╔══██║██║  ██║██║  ██║    ██║   ██║██╔═══╝ ╚════██║
;; ██║  ██║██████╔╝██████╔╝    ╚██████╔╝██║     ███████║
;; ╚═╝  ╚═╝╚═════╝ ╚═════╝      ╚═════╝ ╚═╝     ╚══════╝


;;; Adds a new key-value pair to the dictionary, only if the key doesn't exist.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to add (slice, signed int, or unsigned int).
;;;   value (slice): Value to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary if key was added, original dictionary otherwise.
;;;   int: Success flag: -1 if key was added, 0 if key already existed.
(cell, int) dict_add?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTADD";
(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIADD";
(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUADD";

;;; Adds a new key with a cell value to the dictionary, only if the key doesn't exist.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to add (slice, signed int, or unsigned int).
;;;   value (cell): Cell to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary if key was added, original dictionary otherwise.
;;;   int: Success flag: -1 if key was added, 0 if key already existed.
(cell, int) dict_add_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) "DICTADDREF";
(cell, int) udict_add_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUADDREF";
(cell, int) idict_add_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTIADDREF";

;;; Attempts to add a key-value pair; returns the existing value if the key already exists.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to add (slice, signed int, or unsigned int).
;;;   value (slice): Value to store.
;;;
;;; Returns:
;;;   cell: The resulting dictionary (modified if key was new, original if key existed).
;;;   slice: The existing value if the key already existed (when flag is 0), or null if the key was added (when flag is -1).
;;;   int: Success flag: -1 if key was added, 0 if key already existed.
(cell, slice, int) dict_add_get?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTADDGET" "NULLSWAPIF";
(cell, (slice, int)) ~dict_add_get?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTADDGET" "NULLSWAPIF";
(cell, slice, int) idict_add_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIADDGET" "NULLSWAPIF";
(cell, (slice, int)) ~idict_add_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIADDGET" "NULLSWAPIF";
(cell, slice, int) udict_add_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUADDGET" "NULLSWAPIF";
(cell, (slice, int)) ~udict_add_get?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUADDGET" "NULLSWAPIF";

;;; Attempts to add a key with a cell value; returns existing cell if key exists.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to add (slice, signed int, or unsigned int).
;;;   value (cell): Cell to store.
;;;
;;; Returns:
;;;   cell: The resulting dictionary (modified if key was new, original if key existed).
;;;   cell: The existing cell if the key already existed (when flag is 0), or null if the key was added (when flag is -1).
;;;   int: Success flag: -1 if key was added, 0 if key already existed.
(cell, cell, int) dict_add_get_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) "DICTADDGETREF" "NULLSWAPIF";
(cell, (cell, int)) ~dict_add_get_ref?(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) "DICTADDGETREF" "NULLSWAPIF";
(cell, cell, int) idict_add_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTIADDGETREF" "NULLSWAPIF";
(cell, (cell, int)) ~idict_add_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTIADDGETREF" "NULLSWAPIF";
(cell, cell, int) udict_add_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUADDGETREF" "NULLSWAPIF";
(cell, (cell, int)) ~udict_add_get_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUADDGETREF" "NULLSWAPIF";

;;; Adds a new key with a builder value, only if the key doesn't exist.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to add (slice, signed int, or unsigned int).
;;;   value (builder): Builder containing the value to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary if key was added, original dictionary otherwise.
;;;   int: Success flag: -1 if key was added, 0 if key already existed.
(cell, int) dict_add_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTADDB";
(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIADDB";
(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUADDB";

;;; Attempts to add a key with a builder value; returns existing value if key exists.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to add (slice, signed int, or unsigned int).
;;;   value (builder): Builder containing the value to store.
;;;
;;; Returns:
;;;   cell: The resulting dictionary (modified if key was new, original if key existed).
;;;   slice: The existing value if the key already existed (when flag is 0), or null if the key was added (when flag is -1).
;;;   int: Success flag: -1 if key was added, 0 if key already existed.
(cell, slice, int) dict_add_get_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTADDGETB" "NULLSWAPIF";
(cell, (slice, int)) ~dict_add_get_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTADDGETB" "NULLSWAPIF";
(cell, slice, int) idict_add_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIADDGETB" "NULLSWAPIF";
(cell, (slice, int)) ~idict_add_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIADDGETB" "NULLSWAPIF";
(cell, slice, int) udict_add_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUADDGETB" "NULLSWAPIF";
(cell, (slice, int)) ~udict_add_get_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUADDGETB" "NULLSWAPIF";


;; ██████╗ ███████╗██╗     ███████╗████████╗███████╗     ██████╗ ██████╗ ███████╗
;; ██╔══██╗██╔════╝██║     ██╔════╝╚══██╔══╝██╔════╝    ██╔═══██╗██╔══██╗██╔════╝
;; ██║  ██║█████╗  ██║     █████╗     ██║   █████╗      ██║   ██║██████╔╝███████╗
;; ██║  ██║██╔══╝  ██║     ██╔══╝     ██║   ██╔══╝      ██║   ██║██╔═══╝ ╚════██║
;; ██████╔╝███████╗███████╗███████╗   ██║   ███████╗    ╚██████╔╝██║     ███████║
;; ╚═════╝ ╚══════╝╚══════╝╚══════╝   ╚═╝   ╚══════╝     ╚═════╝ ╚═╝     ╚══════╝


;;; Deletes a key-value pair from the dictionary.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to delete (slice, signed int, or unsigned int).
;;;
;;; Returns:
;;;   cell: The modified dictionary if key found, original dictionary otherwise.
;;;   int: Success flag: -1 if key was found and deleted, 0 otherwise.
(cell, int) dict_delete?(cell dict, int key_len, slice index) asm(index dict key_len) "DICTDEL";
(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDEL";
(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDEL";

;;; Deletes a key-value pair and returns the value that was deleted.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to delete (slice, signed int, or unsigned int).
;;;
;;; Returns:
;;;   cell: The modified dictionary if key existed, original dictionary otherwise.
;;;   slice: The deleted value if the key existed (when flag is -1), or null otherwise (when flag is 0).
;;;   int: Success flag: -1 if key was found and deleted, 0 otherwise.
(cell, slice, int) dict_delete_get?(cell dict, int key_len, slice index) asm(index dict key_len) "DICTDELGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~dict_delete_get?(cell dict, int key_len, slice index) asm(index dict key_len) "DICTDELGET" "NULLSWAPIFNOT";
(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGET" "NULLSWAPIFNOT";
(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGET" "NULLSWAPIFNOT";

;;; Deletes a key-value pair and returns the cell value that was deleted.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to delete (slice, signed int, or unsigned int).
;;;
;;; Returns:
;;;   cell: The modified dictionary if key existed, original dictionary otherwise.
;;;   cell: The deleted cell if the key existed (when flag is -1), or null otherwise (when flag is 0).
;;;   int: Success flag: -1 if key was found and deleted, 0 otherwise.
(cell, cell, int) dict_delete_get_ref?(cell dict, int key_len, slice index) asm(index dict key_len) "DICTDELGETREF" "NULLSWAPIFNOT";
(cell, (cell, int)) ~dict_delete_get_ref?(cell dict, int key_len, slice index) asm(index dict key_len) "DICTDELGETREF" "NULLSWAPIFNOT";
(cell, cell, int) idict_delete_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGETREF" "NULLSWAPIFNOT";
(cell, (cell, int)) ~idict_delete_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGETREF" "NULLSWAPIFNOT";
(cell, cell, int) udict_delete_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGETREF" "NULLSWAPIFNOT";
(cell, (cell, int)) ~udict_delete_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGETREF" "NULLSWAPIFNOT";


;; ███╗   ███╗ █████╗ ██╗   ██╗██████╗ ███████╗    ██████╗ ███████╗███████╗     ██████╗ ██████╗ ███████╗
;; ████╗ ████║██╔══██╗╚██╗ ██╔╝██╔══██╗██╔════╝    ██╔══██╗██╔════╝██╔════╝    ██╔═══██╗██╔══██╗██╔════╝
;; ██╔████╔██║███████║ ╚████╔╝ ██████╔╝█████╗      ██████╔╝█████╗  █████╗      ██║   ██║██████╔╝███████╗
;; ██║╚██╔╝██║██╔══██║  ╚██╔╝  ██╔══██╗██╔══╝      ██╔══██╗██╔══╝  ██╔══╝      ██║   ██║██╔═══╝ ╚════██║
;; ██║ ╚═╝ ██║██║  ██║   ██║   ██████╔╝███████╗    ██║  ██║███████╗██║         ╚██████╔╝██║     ███████║
;; ╚═╝     ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═════╝ ╚══════╝    ╚═╝  ╚═╝╚══════╝╚═╝          ╚═════╝ ╚═╝     ╚══════╝


;;; Retrieves a cell for a key, returning null if the key is absent.
;;;
;;; Args:
;;;   dict (cell): Dictionary to search in.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to look up (slice, signed int, or unsigned int).
;;;
;;; Returns:
;;;   cell: Cell associated with the key, or null if key not found.
cell dict_get_ref(cell dict, int key_len, slice index) asm(index dict key_len) "DICTGETOPTREF";
cell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGETOPTREF";
cell udict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGETOPTREF";

;;; Sets or deletes a cell value for a key and returns the old cell.
;;; If the provided value is null, the key is deleted.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;   index (slice/int): Key to set or delete (slice, signed int, or unsigned int).
;;;   value (cell): Cell to store (or null to delete).
;;;
;;; Returns:
;;;   cell: The modified dictionary.
;;;   cell: The old cell if the key existed, or null if the key was absent before the operation.
(cell, cell) dict_set_get_ref(cell dict, int key_len, slice index, cell value) asm(value index dict key_len) "DICTSETGETOPTREF";
(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETGETOPTREF";
(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETGETOPTREF";


;; ██████╗ ██████╗ ███████╗███████╗██╗██╗  ██╗     ██████╗ ██████╗ ███████╗
;; ██╔══██╗██╔══██╗██╔════╝██╔════╝██║╚██╗██╔╝    ██╔═══██╗██╔══██╗██╔════╝
;; ██████╔╝██████╔╝█████╗  █████╗  ██║ ╚███╔╝     ██║   ██║██████╔╝███████╗
;; ██╔═══╝ ██╔══██╗██╔══╝  ██╔══╝  ██║ ██╔██╗     ██║   ██║██╔═══╝ ╚════██║
;; ██║     ██║  ██║███████╗██║     ██║██╔╝ ██╗    ╚██████╔╝██║     ███████║
;; ╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝     ╚═════╝ ╚═╝     ╚══════╝


;;; Looks up the unique prefix of a given key in a prefix code dictionary.
;;;
;;; Args:
;;;   dict (cell): Prefix code dictionary to search in.
;;;   key_len (int): Maximum length of the key in bits.
;;;   key (slice): Key prefix to look up.
;;;
;;; Returns:
;;;   slice: The matching prefix from the key.
;;;   slice: The remaining suffix of the key that was not matched.
;;;   slice: The value associated with the prefix.
;;;   int: Success flag: -1 if a prefix was found, 0 if not found.
(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) "PFXDICTGETQ" "NULLSWAPIFNOT2";

;;; Sets a value for a key in a prefix dictionary.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Maximum length of the key in bits.
;;;   key (slice): Key to set.
;;;   value (slice): Value to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary if successful, original dictionary otherwise.
;;;   int: Success flag: -1 if set successfully, 0 if an error occurred (e.g., prefix conflict).
(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) "PFXDICTSET";

;;; Replaces a value for a key in a prefix dictionary, only if the key exists.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Maximum length of the key in bits.
;;;   key (slice): Key to replace.
;;;   value (slice): New value to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary if key found, original dictionary otherwise.
;;;   int: Success flag: -1 if replaced successfully, 0 if key not found.
(cell, int) pfxdict_replace?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) "PFXDICTREPLACE";

;;; Adds a key-value pair to a prefix dictionary, only if the key doesn't exist as a key or prefix.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Maximum length of the key in bits.
;;;   key (slice): Key to add.
;;;   value (slice): Value to store.
;;;
;;; Returns:
;;;   cell: The modified dictionary if added successfully, original dictionary otherwise.
;;;   int: Success flag: -1 if added successfully, 0 if key already exists or conflicts.
(cell, int) pfxdict_add?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) "PFXDICTADD";

;;; Deletes a key-value pair from a prefix dictionary if the key exists.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Maximum length of the key in bits.
;;;   key (slice): Key to delete.
;;;
;;; Returns:
;;;   cell: The modified dictionary if key found, original dictionary otherwise.
;;;   int: Success flag: -1 if deleted successfully, 0 if key not found.
(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) "PFXDICTDEL";


;; ███╗   ██╗███████╗██╗  ██╗████████╗ ██╗██████╗ ██████╗ ███████╗██╗   ██╗     ██████╗ ██████╗ ███████╗
;; ████╗  ██║██╔════╝╚██╗██╔╝╚══██╔══╝██╔╝██╔══██╗██╔══██╗██╔════╝██║   ██║    ██╔═══██╗██╔══██╗██╔════╝
;; ██╔██╗ ██║█████╗   ╚███╔╝    ██║  ██╔╝ ██████╔╝██████╔╝█████╗  ██║   ██║    ██║   ██║██████╔╝███████╗
;; ██║╚██╗██║██╔══╝   ██╔██╗    ██║ ██╔╝  ██╔═══╝ ██╔══██╗██╔══╝  ╚██╗ ██╔╝    ██║   ██║██╔═══╝ ╚════██║
;; ██║ ╚████║███████╗██╔╝ ██╗   ██║██╔╝   ██║     ██║  ██║███████╗ ╚████╔╝     ╚██████╔╝██║     ███████║
;; ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝   ╚═╝╚═╝    ╚═╝     ╚═╝  ╚═╝╚══════╝  ╚═══╝       ╚═════╝ ╚═╝     ╚══════╝


;;; Finds the next key after a specified pivot in dictionary traversal order.
;;;
;;; Args:
;;;   dict (cell): Dictionary to search in.
;;;   key_len (int): Length of the key in bits.
;;;   pivot (slice/int): Key to start from (slice, signed int, or unsigned int).
;;;
;;; Returns:
;;;   slice/int: The next key after the pivot (slice, signed int, or unsigned int), or null if no greater key exists.
;;;   slice: The value associated with the next key, or null if no greater key exists.
;;;   int: Success flag: -1 if a next key was found, 0 otherwise.
(slice, slice, int) dict_get_next?(cell dict, int key_len, slice pivot) asm(pivot dict key_len -> 1 0 2) "DICTGETNEXT" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETNEXT" "NULLSWAPIFNOT2";
(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETNEXT" "NULLSWAPIFNOT2";

;;; Finds the next key including the pivot itself in dictionary traversal order.
;;;
;;; Args:
;;;   dict (cell): Dictionary to search in.
;;;   key_len (int): Length of the key in bits.
;;;   pivot (slice/int): Key to start from (slice, signed int, or unsigned int).
;;;
;;; Returns:
;;;   slice/int: The pivot if it exists, otherwise the next key (slice, signed int, or unsigned int), or null if no such key exists.
;;;   slice: The value associated with the returned key, or null if no such key exists.
;;;   int: Success flag: -1 if a key was found (pivot or next), 0 otherwise.
(slice, slice, int) dict_get_nexteq?(cell dict, int key_len, slice pivot) asm(pivot dict key_len -> 1 0 2) "DICTGETNEXTEQ" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETNEXTEQ" "NULLSWAPIFNOT2";
(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETNEXTEQ" "NULLSWAPIFNOT2";

;;; Finds the previous key before a specified pivot in dictionary traversal order.
;;;
;;; Args:
;;;   dict (cell): Dictionary to search in.
;;;   key_len (int): Length of the key in bits.
;;;   pivot (slice/int): Key to start from (slice, signed int, or unsigned int).
;;;
;;; Returns:
;;;   slice/int: The previous key before the pivot (slice, signed int, or unsigned int), or null if no smaller key exists.
;;;   slice: The value associated with the previous key, or null if no smaller key exists.
;;;   int: Success flag: -1 if a previous key was found, 0 otherwise.
(slice, slice, int) dict_get_prev?(cell dict, int key_len, slice pivot) asm(pivot dict key_len -> 1 0 2) "DICTGETPREV" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETPREV" "NULLSWAPIFNOT2";
(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETPREV" "NULLSWAPIFNOT2";

;;; Finds the previous key including the pivot itself in dictionary traversal order.
;;;
;;; Args:
;;;   dict (cell): Dictionary to search in.
;;;   key_len (int): Length of the key in bits.
;;;   pivot (slice/int): Key to start from (slice, signed int, or unsigned int).
;;;
;;; Returns:
;;;   slice/int: The pivot if it exists, otherwise the previous key (slice, signed int, or unsigned int), or null if no such key exists.
;;;   slice: The value associated with the returned key, or null if no such key exists.
;;;   int: Success flag: -1 if a key was found (pivot or previous), 0 otherwise.
(slice, slice, int) dict_get_preveq?(cell dict, int key_len, slice pivot) asm(pivot dict key_len -> 1 0 2) "DICTGETPREVEQ" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETPREVEQ" "NULLSWAPIFNOT2";
(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETPREVEQ" "NULLSWAPIFNOT2";


;; ███╗   ███╗██╗███╗   ██╗    ██╗███╗   ███╗ █████╗ ██╗  ██╗     ██████╗ ██████╗ ███████╗
;; ████╗ ████║██║████╗  ██║   ██╔╝████╗ ████║██╔══██╗╚██╗██╔╝    ██╔═══██╗██╔══██╗██╔════╝
;; ██╔████╔██║██║██╔██╗ ██║  ██╔╝ ██╔████╔██║███████║ ╚███╔╝     ██║   ██║██████╔╝███████╗
;; ██║╚██╔╝██║██║██║╚██╗██║ ██╔╝  ██║╚██╔╝██║██╔══██║ ██╔██╗     ██║   ██║██╔═══╝ ╚════██║
;; ██║ ╚═╝ ██║██║██║ ╚████║██╔╝   ██║ ╚═╝ ██║██║  ██║██╔╝ ██╗    ╚██████╔╝██║     ███████║
;; ╚═╝     ╚═╝╚═╝╚═╝  ╚═══╝╚═╝    ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝     ╚═════╝ ╚═╝     ╚══════╝


;;; Retrieves the minimum key and its value from the dictionary, using lexicographical/signed/unsigned comparison based on the specific function variant.
;;;
;;; Args:
;;;   dict (cell): Dictionary to search in.
;;;   key_len (int): Length of the key in bits.
;;;
;;; Returns:
;;;   slice/int: The minimum key found (slice, signed int, or unsigned int), or null if dictionary is empty.
;;;   slice: The value associated with the minimum key, or null if dictionary is empty.
;;;   int: Success flag: -1 if dictionary is not empty, 0 if empty.
(slice, slice, int) dict_get_min?(cell dict, int key_len) asm (-> 1 0 2) "DICTMIN" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMIN" "NULLSWAPIFNOT2";
(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMIN" "NULLSWAPIFNOT2";

;;; Retrieves the minimum key and its associated cell from the dictionary, using lexicographical/signed/unsigned comparison based on the specific function variant.
;;;
;;; Args:
;;;   dict (cell): Dictionary to search in.
;;;   key_len (int): Length of the key in bits.
;;;
;;; Returns:
;;;   slice/int: The minimum key found (slice, signed int, or unsigned int), or null if dictionary is empty.
;;;   cell: The cell associated with the minimum key, or null if dictionary is empty.
;;;   int: Success flag: -1 if dictionary is not empty, 0 if empty.
(slice, cell, int) dict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTMINREF" "NULLSWAPIFNOT2";
(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMINREF" "NULLSWAPIFNOT2";
(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMINREF" "NULLSWAPIFNOT2";

;;; Retrieves the maximum key and its value from the dictionary, using lexicographical/signed/unsigned comparison based on the specific function variant.
;;;
;;; Args:
;;;   dict (cell): Dictionary to search in.
;;;   key_len (int): Length of the key in bits.
;;;
;;; Returns:
;;;   slice/int: The maximum key found (slice, signed int, or unsigned int), or null if dictionary is empty.
;;;   slice: The value associated with the maximum key, or null if dictionary is empty.
;;;   int: Success flag: -1 if dictionary is not empty, 0 if empty.
(slice, slice, int) dict_get_max?(cell dict, int key_len) asm (-> 1 0 2) "DICTMAX" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMAX" "NULLSWAPIFNOT2";
(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMAX" "NULLSWAPIFNOT2";

;;; Retrieves the maximum key and its associated cell from the dictionary, using lexicographical/signed/unsigned comparison based on the specific function variant.
;;;
;;; Args:
;;;   dict (cell): Dictionary to search in.
;;;   key_len (int): Length of the key in bits.
;;;
;;; Returns:
;;;   slice/int: The maximum key found (slice, signed int, or unsigned int), or null if dictionary is empty.
;;;   cell: The cell associated with the maximum key, or null if dictionary is empty.
;;;   int: Success flag: -1 if dictionary is not empty, 0 if empty.
(slice, cell, int) dict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTMAXREF" "NULLSWAPIFNOT2";
(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMAXREF" "NULLSWAPIFNOT2";
(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMAXREF" "NULLSWAPIFNOT2";

;;; Retrieves and removes the minimum key-value pair from the dictionary, using lexicographical/signed/unsigned comparison based on the specific function variant.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;
;;; Returns:
;;;   cell: The modified dictionary if not empty, original dictionary if empty.
;;;   slice/int: The minimum key that was removed (slice, signed int, or unsigned int), or null if empty.
;;;   slice: The value associated with the removed minimum key, or null if empty.
;;;   int: Success flag: -1 if an entry was removed, 0 if dictionary was empty.
(cell, slice, slice, int) dict_delete_get_min?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMIN" "NULLSWAPIFNOT2";
(cell, (slice, slice, int)) ~dict_delete_get_min?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMIN" "NULLSWAPIFNOT2";
(cell, int, slice, int) idict_delete_get_min?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMIN" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~idict_delete_get_min?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMIN" "NULLSWAPIFNOT2";
(cell, int, slice, int) udict_delete_get_min?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMIN" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~udict_delete_get_min?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMIN" "NULLSWAPIFNOT2";

;;; Retrieves and removes the minimum key and its associated cell from the dictionary, using lexicographical/signed/unsigned comparison based on the specific function variant.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;
;;; Returns:
;;;   cell: The modified dictionary if not empty, original dictionary if empty.
;;;   slice/int: The minimum key that was removed (slice, signed int, or unsigned int), or null if empty.
;;;   cell: The cell associated with the removed minimum key, or null if empty.
;;;   int: Success flag: -1 if an entry was removed, 0 if dictionary was empty.
(cell, slice, cell, int) dict_delete_get_min_ref?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMINREF" "NULLSWAPIFNOT2";
(cell, (slice, cell, int)) ~dict_delete_get_min_ref?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMINREF" "NULLSWAPIFNOT2";
(cell, int, cell, int) idict_delete_get_min_ref?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMINREF" "NULLSWAPIFNOT2";
(cell, (int, cell, int)) ~idict_delete_get_min_ref?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMINREF" "NULLSWAPIFNOT2";
(cell, int, cell, int) udict_delete_get_min_ref?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMINREF" "NULLSWAPIFNOT2";
(cell, (int, cell, int)) ~udict_delete_get_min_ref?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMINREF" "NULLSWAPIFNOT2";

;;; Retrieves and removes the maximum key-value pair from the dictionary, using lexicographical/signed/unsigned comparison based on the specific function variant.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;
;;; Returns:
;;;   cell: The modified dictionary if not empty, original dictionary if empty.
;;;   slice/int: The maximum key that was removed (slice, signed int, or unsigned int), or null if empty.
;;;   slice: The value associated with the removed maximum key, or null if empty.
;;;   int: Success flag: -1 if an entry was removed, 0 if dictionary was empty.
(cell, slice, slice, int) dict_delete_get_max?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMAX" "NULLSWAPIFNOT2";
(cell, (slice, slice, int)) ~dict_delete_get_max?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMAX" "NULLSWAPIFNOT2";
(cell, int, slice, int) idict_delete_get_max?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMAX" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~idict_delete_get_max?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMAX" "NULLSWAPIFNOT2";
(cell, int, slice, int) udict_delete_get_max?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMAX" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~udict_delete_get_max?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMAX" "NULLSWAPIFNOT2";

;;; Retrieves and removes the maximum key and its associated cell from the dictionary, using lexicographical/signed/unsigned comparison based on the specific function variant.
;;;
;;; Args:
;;;   dict (cell): Dictionary to modify.
;;;   key_len (int): Length of the key in bits.
;;;
;;; Returns:
;;;   cell: The modified dictionary if not empty, original dictionary if empty.
;;;   slice/int: The maximum key that was removed (slice, signed int, or unsigned int), or null if empty.
;;;   cell: The cell associated with the removed maximum key, or null if empty.
;;;   int: Success flag: -1 if an entry was removed, 0 if dictionary was empty.
(cell, slice, cell, int) dict_delete_get_max_ref?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMAXREF" "NULLSWAPIFNOT2";
(cell, (slice, cell, int)) ~dict_delete_get_max_ref?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMAXREF" "NULLSWAPIFNOT2";
(cell, int, cell, int) idict_delete_get_max_ref?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMAXREF" "NULLSWAPIFNOT2";
(cell, (int, cell, int)) ~idict_delete_get_max_ref?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMAXREF" "NULLSWAPIFNOT2";
(cell, int, cell, int) udict_delete_get_max_ref?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMAXREF" "NULLSWAPIFNOT2";
(cell, (int, cell, int)) ~udict_delete_get_max_ref?(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMAXREF" "NULLSWAPIFNOT2";


;; ███████╗██╗   ██╗██████╗ ██████╗ ██╗ ██████╗████████╗     ██████╗ ██████╗ ███████╗
;; ██╔════╝██║   ██║██╔══██╗██╔══██╗██║██╔════╝╚══██╔══╝    ██╔═══██╗██╔══██╗██╔════╝
;; ███████╗██║   ██║██████╔╝██║  ██║██║██║        ██║       ██║   ██║██████╔╝███████╗
;; ╚════██║██║   ██║██╔══██╗██║  ██║██║██║        ██║       ██║   ██║██╔═══╝ ╚════██║
;; ███████║╚██████╔╝██████╔╝██████╔╝██║╚██████╗   ██║       ╚██████╔╝██║     ███████║
;; ╚══════╝ ╚═════╝ ╚═════╝ ╚═════╝ ╚═╝ ╚═════╝   ╚═╝        ╚═════╝ ╚═╝     ╚══════╝


;;; Extracts a subdictionary containing all key-value pairs with keys starting with a given prefix.
;;;
;;; Args:
;;;   dict (cell): Dictionary to extract from.
;;;   key_len (int): Length of the key in bits.
;;;   pfx (slice/int): Prefix to match (slice, signed int, or unsigned int).
;;;   pfx_len (int): Length of the prefix in bits.
;;;
;;; Returns:
;;;   cell: A new dictionary containing only entries with keys starting with the given prefix.
cell subdict_get(cell dict, int key_len, slice pfx, int pfx_len) asm(pfx pfx_len dict key_len) "SUBDICTGET";
cell isubdict_get(cell dict, int key_len, int pfx, int pfx_len) asm(pfx pfx_len dict key_len) "SUBDICTIGET";
cell usubdict_get(cell dict, int key_len, int pfx, int pfx_len) asm(pfx pfx_len dict key_len) "SUBDICTUGET";

;;; Extracts a subdictionary starting with a prefix, removing the prefix from keys in the result.
;;;
;;; Args:
;;;   dict (cell): Dictionary to extract from.
;;;   key_len (int): Length of the key in bits.
;;;   pfx (slice/int): Prefix to match (slice, signed int, or unsigned int).
;;;   pfx_len (int): Length of the prefix in bits.
;;;
;;; Returns:
;;;   cell: A new dictionary of type HashmapE(n-l, X) containing entries with keys starting
;;;         with the given prefix, but with the prefix removed from all keys.
cell subdict_get_without_pfx(cell dict, int key_len, slice pfx, int pfx_len) asm(pfx pfx_len dict key_len) "SUBDICTRPGET";
cell isubdict_get_without_pfx(cell dict, int key_len, int pfx, int pfx_len) asm(pfx pfx_len dict key_len) "SUBDICTIRPGET";
cell usubdict_get_without_pfx(cell dict, int key_len, int pfx, int pfx_len) asm(pfx pfx_len dict key_len) "SUBDICTURPGET";
